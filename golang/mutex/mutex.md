# Mutex、RWMutex锁



## Mutex
mutex几种状态

- `mutexLocked` — 表示互斥锁的锁定状态；
- `mutexWoken` — 表示从正常模式被从唤醒；
- `mutexStarving` — 当前的互斥锁进入饥饿状态；
- `waitersCount` — 当前互斥锁上等待的 Goroutine 个数；

**正常模式(非公平锁)**

正常模式下，所有等待锁的goroutine按照FIFO(先进先出)顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式。

**饥饿模式(公平锁)**

为了解决了等待G队列的长尾问题
饥饿模式下，直接由unlock把锁交给等待队列中排在第一位的G(队头)，同时，饥饿模式下，新进来的G不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部,这样很好的解决了老的g一直抢不到锁的场景。
饥饿模式的触发条件，当一个G等待锁时间超过1毫秒时，或者当前队列只剩下一个g的时候，Mutex切换到饥饿模式。

**总结**

对于两种模式，正常模式下的性能是最好的，goroutine可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的一个平衡模式。

**补充**

- 允许自旋的条件

  1 锁已被占用，并且锁不处于饥饿模式。

  2 积累的自旋次数小于最大自旋次数（active_spin=4）。

  3 cpu核数大于1。

  4 有空闲的P。

  5 当前goroutine所挂载的P下，本地待运行队列为空。
  
  

## RWMutex

通过记录readerCount 读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数1<<30。目的是让新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进行后续的操作。 而等写锁释放完之后，会将值重新加上1<<30, 并通知刚才新进入的读锁(rw.readerSem)，两者互相限制



cpu的指令重排 

内存屏障，CPU提供了 barrier指令


### Go 中不要拷贝锁



## Reference

[golang中的锁源码实现](http://legendtkl.com/2016/10/23/golang-mutex/)

[很细，mutex中runtime队列说法](http://birjemin.com/wiki/go-lock2)

